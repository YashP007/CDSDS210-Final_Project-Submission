# CDSDS210-Final_Project-Submission
Yash Patel (U11247717)

Hello, 

This is my final project for CDS DS210: Programming for Data Science. The data that was used was a list of spotify tracks, artist, and playlists. The data was organized by which song is in which playlist, with this data the artist information was provided. With this algorithim I aimed to create graph data from the choosen data and then create an algorithm that would recamend a playlist to listen to based on a given playlist that is enjoyed. Since the purpose of this project is to perform some analysis of graph data that submitted files are not the entire recamendation software, because the given playlist is hard coded into the program. The motivation behind this alogorthm was to create a more effient and effective method for playlist recamendation. Many songs and user created playlists based on the content of the songs perform much better than playlists created from style and artist. So by using the taste and how users group songs together a more powerful and better recommendation engine can be built. This recommendation engine can benefit and recommend playlists to users more efficiently.

My choosen data //  python programming

### Data Parsing & Generating HashMap Adjacency Lists
My submitted program goes through a series of graphs to interpolate a better recamendation. Initally a graph tree was created with the nodes being the playlist and the nodes it pointed to being the artists it contains. I used a HashMap<String, Vec<String>> to store this graph data, the data was stored in the format of a adjacency list. I parse through the data set, which was sampled to a size around 500,000 lines. For each line of data, I checked if the node for the playlist was created, if it was not I use the HashMap .insert() function to add a new node (key), with the value being the artist in a Vec<String> format. If the playlist node was already created then I find the value using the node name as the key loop up, I then check if the value contains the artist that is presented in the line of the data sheet. If the artist is in the value vector, then I do nothing, if it is not, then I add the artist into the value vector. Using this logic I parse through my entire data file, and generate a HashMap with the key's being the Playlists and the values being a list of the artists the playlist features. I repeate this processes in reverse. 

  
By repeating this processes in reverse I mean creating another adjacency list, representing a graph, where the key are the artists, and the values are a Vec<String> of the Playlists that feature them. I did these processes in `make_hashmap` and `make_rev_hashmap` functions in the `make_graphs.rs` file. This means I have two representations of the same graph data that can be used for different things. I then choose to use both of these graphs together to generate connections between playlists. 

### Generating Recommendation Graph
To generate the desired recommendation graph data with connections, I looped through playlist -> artist hash map, to get each playlist that it is connected to. This algorithm and code can be seen in `make_graphs.rs` in function `hash_map_playlist_playlist`. This function generates a new HashMap, with the keys being each playlist, and the values being a list(Vec<String>) of all of the playlists it shares featuring artists on. The way that it does this is by using the playlist->artists HashMap to get the artist a given playlist features, and then uses the Artist -> Playlist HashMap to get all of the playlists that feature those artists,  while removing duplicates. This HashMap will be the main adjacency list I will use for the rest of my program to make recommendations and run algorithms on. This graph was extrapolated from the given data. This was important to do because often the given data is not optimized for graph algorithms, but graph based algorithms often recommend the best solutions to proposed issues. So it is integral to know and be able to transform any given data to fit graph algorithm, when appropriate. 

### One-Node-Away Recommendation
It is import to understand what the aim of this project is, and what type of graph that has been created. I am trying to provide a recommendation that the user will enjoy listening to, so it does not make sense to 
